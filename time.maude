mod TIME is
  protecting ACTUATORS .

  sort Clock TimedConfiguration .
  subsort Clock < Configuration .

  sort Timesteps Time .
  subsort Nat < Timesteps .
  subsort Nat < Time .                  *** TODO: Should we specify that 0 <= Time < 24?

  *** We need the timed configuration to ensure that the time advance rule is only applied to the full configuration
  op {_} : Configuration -> TimedConfiguration .

  op < _ :Clock | Timesteps: _, Time: _ > : Oid Timesteps Time -> Clock [format (ntb b b b b b b b b b o)] .

  op getTime : Timesteps -> Time .
  op morning? : Time -> Bool .              *** For the controllers it's important to know whether it's morning or not

  op canAdvance : Configuration -> Bool .   *** Determines whether the time can advance or not
  op advance : Configuration -> Configuration .   *** Advances the time by one step and sets the rule guards to 'no'




  vars TS : Timesteps .
  var N : Nat .
  vars H WH W T C CC EC AQ : Oid .
  var HS : HeaterStatus .
  var WHS : WaterheaterStatus .
  var WS : WindowStatus .
  var TI : Time .
  var RA : RuleAppliedTemp .
  var RAAQ : RuleAppliedAQ .
  vars ET ET1 ET2 : EffectTemp .
  vars EAQ EAQ1 EAQ2 : EffectAQ .
  var B : Broken .
  vars CONF : Configuration .

  *** Compute time with given time steps as Timesteps mod 24
  eq getTime(TS) = TS rem 24 .

  *** Define morning to be between 6 and 12 o'clock.
  ceq morning?(N) = true if 6 <= N /\ N <= 12 .
  eq morning?(N) = false [owise] .

  *** We don't want to specify for each component in the system, that it has no effect on the time, so we only specify in which cases that time should NOT advance
  eq canAdvance(< H :Heater | Status: HS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET, EffectsAQ: EAQ, Broken: B > CONF) = false .
  eq canAdvance(< H :Heater | Status: HS, RuleAppliedTemp: no, RuleAppliedAQ: yes, EffectsTemp: ET, EffectsAQ: EAQ, Broken: B > CONF) = false .
  eq canAdvance(< H :Heater | Status: HS, RuleAppliedTemp: yes, RuleAppliedAQ: no, EffectsTemp: ET, EffectsAQ: EAQ, Broken: B > CONF) = false .
  eq canAdvance(< WH :Waterheater | Status: WHS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET1, EffectsAQ: EAQ1, Broken: B > CONF) = false .
  eq canAdvance(< WH :Waterheater | Status: WHS, RuleAppliedTemp: no, RuleAppliedAQ: yes, EffectsTemp: ET1, EffectsAQ: EAQ1, Broken: B > CONF) = false .
  eq canAdvance(< WH :Waterheater | Status: WHS, RuleAppliedTemp: yes, RuleAppliedAQ: no, EffectsTemp: ET1, EffectsAQ: EAQ1, Broken: B > CONF) = false .
  eq canAdvance(< W :Window | Status: WS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET2, EffectsAQ: EAQ2, Broken: B > CONF) = false .
  eq canAdvance(< W :Window | Status: WS, RuleAppliedTemp: no, RuleAppliedAQ: yes, EffectsTemp: ET2, EffectsAQ: EAQ2, Broken: B > CONF) = false .
  eq canAdvance(< W :Window | Status: WS, RuleAppliedTemp: yes, RuleAppliedAQ: no, EffectsTemp: ET2, EffectsAQ: EAQ2, Broken: B > CONF) = false .
  eq canAdvance(CONF) = true [owise] .

  *** These equations can be applied independent of the rule applied statuses of the actuators (maybe we want to use it for something else too)
  eq advance(< H :Heater | Status: HS, RuleAppliedTemp: RA, RuleAppliedAQ: RAAQ, EffectsTemp: ET, EffectsAQ: EAQ, Broken: B > CONF)
      = < H :Heater | Status: HS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET, EffectsAQ: EAQ, Broken: B > advance(CONF) .
  eq advance(< WH :Waterheater | Status: WHS, RuleAppliedTemp: RA, RuleAppliedAQ: RAAQ, EffectsTemp: ET1, EffectsAQ: EAQ1, Broken: B > CONF)
      = < WH :Waterheater | Status: WHS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET1, EffectsAQ: EAQ1, Broken: B > advance(CONF) .
  eq advance(< W :Window | Status: WS, RuleAppliedTemp: RA, RuleAppliedAQ: RAAQ, EffectsTemp: ET2, EffectsAQ: EAQ2, Broken: B > CONF)
      = < W :Window | Status: WS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET2, EffectsAQ: EAQ2, Broken: B > advance(CONF) .
  eq advance(CONF) = CONF [owise] .


  crl [timeAdvances] :
    {< C :Clock | Timesteps: TS, Time: TI > CONF}
    =>
    {< C :Clock | Timesteps: TS + 1, Time: getTime(TS + 1) > advance(CONF)}
    if canAdvance(CONF)
    [print "rule: [timeAdvances]"] .



endm
eof

*** Rule time
rl [timeAdvances] :
  < H :Heater | Status: HS, RuleAppliedTemp: yes, RuleAppliedAQ: yes, EffectsTemp: ET, EffectsAQ: EAQ, Broken: no >
  < WH :Waterheater | Status: WHS, RuleAppliedTemp: yes, RuleAppliedAQ: yes, EffectsTemp: ET1, EffectsAQ: EAQ1, Broken: no >
  < W :Window | Status: WS, RuleAppliedTemp: yes, RuleAppliedAQ: yes, EffectsTemp: ET2, EffectsAQ: EAQ2, Broken: no >
  < C :Clock | Timesteps: TS, Time: TI >
  =>
  < H :Heater | Status: HS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET, EffectsAQ: EAQ, Broken: no >
  < WH :Waterheater | Status: WHS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET1, EffectsAQ: EAQ1, Broken: no >
  < W :Window | Status: WS, RuleAppliedTemp: no, RuleAppliedAQ: no, EffectsTemp: ET2, EffectsAQ: EAQ2, Broken: no >
  < C :Clock | Timesteps: TS + 1, Time: getTime(TS + 1) >
  [print "rule: [timeAdvancesHWH]"] .
