mod QUALITYATTRIBUTES is
  protecting PHYSICS .
  protecting RAT .

  var CONF : Configuration .
  vars H W WH E T C AQ : Oid .
  var DG : Temperature .
  var AQS : AirqualityStatus .
  var B : Broken .
  var A : Actuator .
  var QAL : QaList .
  vars QAS newQAS : QaStatus .
  vars N M : Nat .
  var BL : Bool .
  var AT : Attribute .
  var EL : EcoList .

  sort QAComputed .
  ops yes no : -> QAComputed .

  ******************************** Relevant for quality attributes comfort and air quality
  sort QaList QaStatus .
  subsort Bool < QaList .
  subsort Rat < QaStatus .
  *** A list which contains the boolean values for the last time steps
  op nil : -> QaList [ctor] .
  op __ : QaList QaList -> QaList [ctor assoc id: nil] .

  *** Get the n last added elements of a list (we suppose that QaList has at least n elements)
  *** TODO ensure that QaList has at least n elements?
  op getLast(_, _) : Nat QaList -> QaList .
  eq getLast(0, QAL) = nil .
  eq getLast(1, BL) = BL .
  eq getLast(s(N), QAL BL) = getLast(N, QAL) BL .

  *** Compute the number of 'true' in a QaList
  op computeTrue : QaList -> Nat .
  eq computeTrue(nil) = 0 .
  eq computeTrue(true) = 1 .
  eq computeTrue(false) = 0 .
  eq computeTrue(QAL true) = 1 + computeTrue(QAL) .
  eq computeTrue(QAL false) = computeTrue(QAL) .

  *** Compute the value of the quality attribute comfort or ecology as the percentage of time in the last n time steps that the temperature was comfortable/ air quality was good
  op computeQA(_, _) : Nat QaList -> QaStatus .
  eq computeQA(0, QAL) = 0 .
  eq computeQA(N, QAL) = computeTrue(getLast(N,QAL)) / N .


  ********************************* Comfort
  sort Comfort .
  subsort Comfort < Configuration .

  *** Determine whether current configuration is in comfortable temperature or not (between 20 and 22 degrees)
  op comfortable? : Configuration -> Bool .
  ceq comfortable?(< T :Thermometer | Degrees: DG > CONF) = true
    if 20.0 <= DG and DG <= 22.0 .
  eq comfortable?(CONF) = false [owise] .

  *** Adds a new boolean value to the list
  op addToListC(_, _) : Configuration QaList -> QaList .
  eq addToListC(none, QAL) = QAL .
  eq addToListC(CONF, QAL) = QAL comfortable?(CONF) .

  *** We can specify the number of time steps that we want to consider when computing the comfort value here
  op < _ :QaComfort | Consider: _, Past: _, Status: _, QAComputed: _ > : Oid Nat QaList QaStatus QAComputed -> Comfort [format (ntg g g g g g g g g g g g g g g g g)] .




  ****************************************** Air quality
  sort QaAirquality .
  subsort QaAirquality < Configuration .

  *** Determine whether current configuration is in good air quality status or not (above 2)
  op aqGood? : Configuration -> Bool .
  ceq aqGood?(< AQ :Airquality | Value: AQS > CONF) = true
    if AQS >= 2.0  .
  eq aqGood?(CONF) = false [owise] .

  *** Adds a new boolean value to the list
  op addToListAq(_, _) : Configuration QaList -> QaList .
  eq addToListAq(none, QAL) = QAL .
  eq addToListAq(CONF, QAL) = QAL aqGood?(CONF) .

  *** We can specify the number of time steps that we want to consider when computing the air quality QA value here
  op < _ :QaAirquality | Consider: _, Past: _, Status: _, QAComputed: _ > : Oid Nat QaList QaStatus QAComputed -> QaAirquality [format (ntg g g g g g g g g g g g g g g g g)] .



  **************************************** Ecology
  sort Ecology EcoList .
  subsort Ecology < Configuration .
  subsort Nat < EcoList .

  *** List of energy consumption values of different time steps
  op nil : -> EcoList [ctor] .
  op __ : EcoList EcoList -> EcoList [ctor assoc id: nil] .

  *** The current energy consumption is computed in every time step as the sum of energy consumption by all actuators
  op getEnergyconsumption : Configuration -> Nat .
  eq getEnergyconsumption(< H :Heater | Status: fairlyhot, AT > CONF) = 2 + getEnergyconsumption(CONF) .
  eq getEnergyconsumption(< H :Heater | Status: veryhot, AT > CONF) = 4 + getEnergyconsumption(CONF) .
  eq getEnergyconsumption(< WH :Waterheater | Status: on, AT > CONF) = 1 + getEnergyconsumption(CONF) .
  eq getEnergyconsumption(CONF) = 0 [owise] .

  *** Adds a new energy consumption value to the list
  op addToListEco(_, _) : Configuration EcoList -> EcoList .
  eq addToListEco(none, EL) = EL .
  eq addToListEco(CONF, EL) = EL getEnergyconsumption(CONF) .

  *** Gets the last N entries
  op getLastEco(_,_) : Nat EcoList -> EcoList .
  eq getLastEco(0, EL) = nil .
  eq getLastEco(1, M) = M .
  eq getLastEco(s(N), EL M) = getLastEco(N, EL) M .

  *** Sums entries
  op sum : EcoList -> Nat .
  eq sum(nil) = 0 .
  eq sum(N EL) = N + sum(EL) .

  *** Computes the quality attribute value as the average of the last N time steps
  op computeEcoQa(_,_) : Nat EcoList -> QaStatus .
  eq computeEcoQa(0, EL) = 0 .
  eq computeEcoQa(N, EL) = sum(getLastEco(N, EL)) / N .

  op < _ :QaEcology | Consider: _, Past: _, Status: _, QAComputed: _ > : Oid Nat EcoList QaStatus QAComputed -> Ecology [format (ntg g g g g g g g g g g g g g g g g)] .




  ****************************************** Rules

  *** The value of the QAs should be computed every time step
  *** TODO How do we ensure that the rule is applied every time step?
  crl [QaEcology] :
    {< E :QaEcology | Consider: N, Past: EL, Status: QAS, QAComputed: no > CONF}
    =>
    {< E :QaEcology | Consider: N, Past: addToListEco(CONF, EL), Status: newQAS, QAComputed: yes > CONF}
    if actuatorsReady(CONF) == true /\ newQAS := computeEcoQa(N, addToListEco(CONF, EL))
    [print "rule: [QaEcology], QA Ecology before: " QAS ", QA Ecology after: " newQAS] .

  crl [QaComfort] :
    {< C :QaComfort | Consider: N, Past: QAL, Status: QAS, QAComputed: no > CONF}
    =>
    {< C :QaComfort | Consider: N, Past: addToListC(CONF, QAL), Status: newQAS, QAComputed: yes > CONF}
    if actuatorsReady(CONF) == true /\ newQAS := computeQA(N, addToListC(CONF, QAL))
    [print "rule: [QaComfort], QA Comfort before: " QAS ", QA Comfort after: " newQAS] .

  crl [QaAirquality] :
    {< AQ :QaAirquality | Consider: N, Past: QAL, Status: QAS, QAComputed: no > CONF}
    =>
    {< AQ :QaAirquality | Consider: N, Past: addToListAq(CONF, QAL), Status: newQAS, QAComputed: yes > CONF}
    if actuatorsReady(CONF) == true /\ newQAS := computeQA(N, addToListAq(CONF, QAL))
    [print "rule: [QaAirquality], QA Airquality before: " QAS ", QA Airquality after: " newQAS] .




endm
