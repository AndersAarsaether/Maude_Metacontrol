mod QUALITYATTRIBUTES is
  protecting PHYSICS .
  protecting RAT .
  protecting LIST{Bool} .
  protecting LIST{Nat} .


  var CONF : Configuration .
  vars H W WH E T C AQ : Oid .
  var DG : Temperature .
  var AQS : AirqualityStatus .
  var A : Actuator .
  vars QAS newQAS : QaStatus .
  vars N M : Nat .
  var BL : Bool .
  var AT : Attribute .
  vars B B1 B2 B3 : Bool .
  var QAC : QAComputed .
  var QAL newQAL : List{Bool} .
  var EL newEL : List{Nat} .

  sort QAComputed .
  ops yes no : -> QAComputed .

  *** The required QA values
  *** TODO Do we really want to name the object "Objective"?
  sort RequQAs Objective .
  subsort Objective < Configuration .
  op requQaCT: _ : Rat -> RequQAs [ctor] .
  op requQaAP: _ : Rat -> RequQAs [ctor] .
  op _, _ : RequQAs RequQAs -> RequQAs [ctor comm assoc] .

  op < RequiredQAs | _ > : RequQAs -> Objective [format(ntc c c c c c)].


  ******************************** Relevant for quality attributes comfort and air quality
  sort QaStatus .
  subsort Rat < QaStatus .

  *** Get the n last added elements of a list (we suppose that List{Bool} has at least n elements)
  *** TODO ensure that List{Bool} has at least n elements?
  op getLast : Nat List{Bool} -> List{Bool} .
  eq getLast(0, QAL) = nil .
  eq getLast(1, BL) = BL .
  eq getLast(s(N), QAL BL) = getLast(N, QAL) BL .

  *** Compute the number of 'true' in a List{Bool}
  op computeTrue : List{Bool} -> Nat .
  eq computeTrue(nil) = 0 .
  eq computeTrue(true) = 1 .
  eq computeTrue(false) = 0 .
  eq computeTrue(QAL true) = 1 + computeTrue(QAL) .
  eq computeTrue(QAL false) = computeTrue(QAL) .

  *** Compute the value of the quality attribute comfort or ecology as the percentage of time in the last n time steps that the temperature was comfortable/ air quality was good
  op computeQA : Nat List{Bool} -> QaStatus .
  ceq computeQA(N, QAL) = computeTrue(getLast(N,QAL)) / N
    if N <= size(QAL) .
  ceq computeQA(N, QAL) = computeTrue(QAL) / M
    if M := size(QAL) /\ N > M .


  ********************************* Comfort
  sort Comfort .
  subsort Comfort < Configuration .

  *** Determine whether current configuration is in comfortable temperature or not (between 20 and 22 degrees)
  op comfortable? : Configuration -> Bool .
  ceq comfortable?(< T :Thermometer | Degrees: DG > CONF) = true
    if 19.1 <= DG and DG <= 21.5 .
  eq comfortable?(CONF) = false [owise] .

  *** We can specify the number of time steps that we want to consider when computing the comfort value here
  op < _ :QaComfort | Consider: _, Past: _, Status: _, QAComputed: _ > : Oid Nat List{Bool} QaStatus QAComputed -> Comfort [format (ntg g g g g g g g g g g g g g g g g)] .

  op getQaCtMeas : Configuration -> QaStatus .
  eq getQaCtMeas(< C :QaComfort | Consider: N, Past: QAL, Status: QAS, QAComputed: QAC > CONF) = QAS .
  eq getQaCtMeas(CONF) = 0 [owise] .


  ****************************************** Air quality
  sort QaAirquality .
  subsort QaAirquality < Configuration .

  *** Determine whether current configuration is in good air quality status or not (above 2)
  op aqGood? : Configuration -> Bool .
  ceq aqGood?(< AQ :Airquality | Value: AQS > CONF) = true
    if AQS >= 0.7  .
  eq aqGood?(CONF) = false [owise] .

  *** We can specify the number of time steps that we want to consider when computing the air quality QA value here
  op < _ :QaAirquality | Consider: _, Past: _, Status: _, QAComputed: _ > : Oid Nat List{Bool} QaStatus QAComputed -> QaAirquality [format (ntg g g g g g g g g g g g g g g g g)] .

  op getQaAqMeas : Configuration -> QaStatus .
  eq getQaAqMeas(< AQ :QaAirquality | Consider: N, Past: QAL, Status: QAS, QAComputed: QAC > CONF) = QAS .
  eq getQaAqMeas(CONF) = 0 [owise] .



  ***************************************** For scheduler
  op QAready : Configuration -> Bool .
  eq QAready(< C :QaComfort | Consider: N, Past: QAL, Status: QAS, QAComputed: no > CONF) = false .
  eq QAready(< AQ :QaAirquality | Consider: N, Past: QAL, Status: QAS, QAComputed: no > CONF) = false .
  eq QAready(CONF) = true [owise] .




  ****************************************** Rules

  *** The value of the QAs should be computed every time step
  crl [QaComfort] :
    {< C :QaComfort | Consider: N, Past: QAL, Status: QAS, QAComputed: no >
    < Scheduler | Status: QAChange, RuleApplied: B > CONF}
    =>
    {< C :QaComfort | Consider: N, Past: newQAL, Status: newQAS, QAComputed: yes >
    < Scheduler | Status: QAChange, RuleApplied: B > CONF}
    if newQAL := append(QAL, comfortable?(CONF)) /\ newQAS := computeQA(N, newQAL)
    [print "rule: [QaComfort], QA Comfort before: " QAS ", QA Comfort after: " newQAS] .

  crl [QaAirquality] :
    {< AQ :QaAirquality | Consider: N, Past: QAL, Status: QAS, QAComputed: no >
    < Scheduler | Status: QAChange, RuleApplied: B > CONF}
    =>
    {< AQ :QaAirquality | Consider: N, Past: newQAL, Status: newQAS, QAComputed: yes >
    < Scheduler | Status: QAChange, RuleApplied: B > CONF}
    if newQAL := append(QAL, aqGood?(CONF)) /\ newQAS := computeQA(N, newQAL)
    [print "rule: [QaAirquality], QA Airquality before: " QAS ", QA Airquality after: " newQAS] .

endm
eof
