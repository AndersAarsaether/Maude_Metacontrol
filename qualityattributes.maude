mod QUALITYATTRIBUTES is
  protecting SENSORS .
  protecting RAT .

  var CONF : Configuration .
  vars H W WH E T C : Oid .
  var HS : HeaterStatus .
  var WHS : WaterheaterStatus .
  var WS : WindowStatus .
  var DG : Temperature .
  vars ET : EffectTemp .
  vars EAQ : EffectAQ .
  vars RA : RuleAppliedTemp .
  vars RAAQ : RuleAppliedAQ .
  var B : Broken .
  var EC : Energyconsumption .
  var A : Actuator .
  var CL : ComfortList .
  var CS : ComfortStatus .
  var N : Nat .
  var BL : Bool .

  *** Ecology
  sort Energyconsumption Ecology .
  subsort Ecology < Configuration .
  subsort Float < Energyconsumption .

  op < _ :Ecology | Value: _ > : Oid Energyconsumption -> Ecology [format (ntg g g g g g g g)] .

  *** The current energy consumption is computed in every time step as the sum of energy consumption by all actuators
  op getEnergyconsumption : Configuration -> Energyconsumption .
  *** The quality attribute value is the difference between the desired and current value
  *** QA > 0 means less energy consumption, QA < 0 means more energy consumption
  op qaEcology : Configuration -> Float .

  eq getEnergyconsumption(< H :Heater | Status: fairlyhot, RuleAppliedTemp: RA, RuleAppliedAQ: RAAQ, EffectsTemp: ET, EffectsAQ: EAQ, Broken: B > CONF) = 2.0 + getEnergyconsumption(CONF) .
  eq getEnergyconsumption(< H :Heater | Status: veryhot, RuleAppliedTemp: RA, RuleAppliedAQ: RAAQ, EffectsTemp: ET, EffectsAQ: EAQ, Broken: B > CONF) = 4.0 + getEnergyconsumption(CONF) .
  eq getEnergyconsumption(< WH :Waterheater | Status: on, RuleAppliedTemp: RA, RuleAppliedAQ: RAAQ, EffectsTemp: ET, EffectsAQ: EAQ, Broken: B > CONF) = 1.0 + getEnergyconsumption(CONF) .
  eq getEnergyconsumption(CONF) = 0.0 [owise] .

  eq qaEcology(CONF) = 2.0 - getEnergyconsumption(CONF) .



  *** Comfort
  sort Comfort ComfortList ComfortStatus .
  subsort Comfort < Configuration .
  subsort Bool < ComfortList .
  subsort Rat < ComfortStatus .

  *** Determine whether current configuration is in comfortable temperature or not (between 20 and 22 degrees)
  op comfortable? : Configuration -> Bool .
  ceq comfortable?(< T :Thermometer | Degrees: DG > CONF) = true
    if 20.0 <= DG and DG <= 22.0 .
  eq comfortable?(CONF) = false [owise] .

  *** A list which contains the comfortable? values for the last time steps
  op nil : -> ComfortList [ctor] .
  op __ : ComfortList ComfortList -> ComfortList [ctor assoc] .

  *** Adds a new boolean value to the list
  op addToList(_, _) : Configuration ComfortList -> ComfortList .
  eq addToList(none, CL) = CL .
  eq addToList(CONF, CL) = CL comfortable?(CONF) .

  *** Get the n last added elements of a list (we suppose that ComfortList has at least n elements)
  *** TODO ensure that ComfortList has at least n elements?
  op getLast(_, _) : Nat ComfortList -> ComfortList .
  eq getLast(0, CL) = nil .
  eq getLast(1, BL) = BL .
  eq getLast(s(N), CL BL) = getLast(N, CL) BL .

  *** Compute the number of 'true' in a ComfortList
  op computeTrue : ComfortList -> Nat .
  eq computeTrue(nil) = 0 .
  eq computeTrue(true) = 1 .
  eq computeTrue(false) = 0 .
  eq computeTrue(CL true) = 1 + computeTrue(CL) .
  eq computeTrue(CL false) = computeTrue(CL) .

  *** Compute the value of the quality attribute as the percentage of time in the last n time steps that the temperature was comfortable
  op qaComfort(_, _) : Nat ComfortList -> ComfortStatus .
  eq qaComfort(N, CL) = computeTrue(getLast(N,CL)) / N .

  *** We can specify the number of time steps that we want to consider when computing the comfort value  here
  op < _ :Comfort | Consider: _, Past: _, Status: _ > : Oid Nat ComfortList ComfortStatus -> Comfort [format (ntg g g g g g g g g g g g g g)].





  *** Rules

  *** The value of the QAs should be computed every time step
  *** TODO How do we ensure that the rule is applied every time step?
  crl [QaEcology] :
    {< E :Ecology | Value: EC > CONF}
    =>
    {< E :Ecology | Value: qaEcology(CONF) > CONF}
    if canAdvance(CONF) == true
    [print "QA Ecology = " EC ", rule: [QaEcology]"] .

  crl [QaComfort] :
    {< C :Comfort | Consider: N, Past: CL, Status: CS > CONF}
    =>
    {< C :Comfort | Consider: N, Past: CL, Status: qaComfort(N, addToList(CONF, CL)) > CONF}
    if canAdvance(CONF) == true
    [print "QA Comfort = " CS ", rule: [QaComfort]"] .

endm
