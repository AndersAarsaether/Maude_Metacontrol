in comfort_controller.maude
in eco_controller.maude
in heater_err_controller.maude
in wh_error_controller.maude
in window_error_controller.maude
in qualityattributes.maude

mod METACONTROL is
  protecting COMFORTCONTROLLER .
  protecting ECOCONTROLLER .
  protecting HEATERERRCONTROLLER .
  protecting WATERHEATERERRCONTROLLER .
  protecting WINDOWERRCONTROLLER .
  protecting QUALITYATTRIBUTES .


  sort Metacontroller .
  subsort Metacontroller < Configuration .

  sorts ContrSelected MetaPair MetaLog .
  subsort MetaPair < MetaLog .
  ops Eco Comf HErr WhErr WErr : -> ContrSelected [ctor] .
  op (_, _) : Timesteps ContrSelected -> MetaPair [ctor] .
  op nil : -> MetaLog [ctor] .
  op __ : MetaLog MetaLog -> MetaLog [ctor assoc id: nil] .

  op < _ :Metacontroller | MetaLog: _ > : Oid MetaLog -> Metacontroller [format (ntr r r r r r r o)] .


  ********** Objects for Function Designs
  sorts RequComponents FunctionDesign .
  subsort FunctionDesign < Configuration .

  ops heater waterheater window : -> RequComponents [ctor] .
  op _, _ : RequComponents RequComponents -> RequComponents [ctor assoc comm] .

  op < _ :FDComfortController | ExpQaCT: _, ExpQaAQ: _, RequComponents: _ > : Oid Rat Rat RequComponents -> FunctionDesign [format (ntr r r r r r r r r r r r r o)] .
  op < _ :FDEcoController | ExpQaCT: _, ExpQaAQ: _, RequComponents: _ > : Oid Rat Rat RequComponents -> FunctionDesign [format (ntr r r r r r r r r r r r r o)] .
  op < _ :FDDeg1Controller | ExpQaCT: _, ExpQaAQ: _, RequComponents: _ > : Oid Rat Rat RequComponents -> FunctionDesign [format (ntr r r r r r r r r r r r r o)] .
  op < _ :FDDeg2Controller | ExpQaCT: _, ExpQaAQ: _, RequComponents: _ > : Oid Rat Rat RequComponents -> FunctionDesign [format (ntr r r r r r r r r r r r r o)] .
  op < _ :FDDeg3Controller | ExpQaCT: _, ExpQaAQ: _, RequComponents: _ > : Oid Rat Rat RequComponents -> FunctionDesign [format (ntr r r r r r r r r r r r r o)] .

  *** Object that indicates whether FG and QAs are in error.
  sort InError .
  subsort InError < Configuration .
  *** TODO maybe we have to include QaEC here if we want to keep it
  op < FGinError: _, QaCTinError: _, QaAQinError: _ > : Bool Bool Bool -> InError [format(ntc c c c c c c c c c c)].

  *** Deselect Function Grounding
  op deselect : Configuration -> Configuration .
  eq deselect(< HEC :HeaterErrController | Selected: S > CONF) = < HEC :HeaterErrController | Selected: S > deselect(CONF) .
  eq deselect(< WHEC :WaterheaterErrController | Selected: S > CONF) = < WHEC :WaterheaterErrController | Selected: S > deselect(CONF) .
  eq deselect(< WEC :WindowErrController | Selected: S > CONF) = < WEC :WindowErrController | Selected: S > deselect(CONF) .
  eq deselect(< CC :ComfortController | Selected: S > CONF) = < CC :ComfortController | Selected: S > deselect(CONF) .
  eq deselect(< EC :EcoController | Selected: S > CONF) = < EC :EcoController | Selected: S > deselect(CONF) .
  eq deselect(CONF) = CONF [owise] .

  vars H WH W CC EC HEC WHEC WEC MC QAC QAAQ C : Oid .
  var HS : HeaterStatus .
  var WHS : WaterheaterStatus .
  var WS : WindowStatus .
  var A : Attribute .
  var N : Nat .
  var QAL : List{Bool} .
  var QAS : QaStatus .
  var QACOM : QAComputed .
  var CONF : Configuration .
  var SC : ScheduleComponents .
  vars B B1 B2 B3 newB newB1 : Bool .
  var R : Rat .
  var ML : MetaLog .
  var TS : Timesteps .
  var TI : Time .
  vars TL AL : TVPList .
  vars S S1 S2 : Selected .
  vars RCT RAQ : Rat .

  **************************** ANALYSE
  ************ Actuators in error
  *** If an actuator is broken, turn it off, set FG to be in error and QAs to be not in error
  *** (because we don't want to use the rules that include QAs)
  *** Put all controllers to 'not selected'
  rl [AnalyseHeaterError] :
    {< H :Heater | Broken: yes, Status: HS, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: false >
    < FGinError: false, QaCTinError: B, QaAQinError: B1 >
    CONF}
    =>
    {< H :Heater | Broken: yes, Status: hOff, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: true >
    < FGinError: true, QaCTinError: false, QaAQinError: false >
    deselect(CONF)}
    [print "rule: [AnalyseHeaterError]"] .

  rl [AnalyseWaterheaterError] :
    {< WH :Waterheater | Broken: yes, Status: WHS, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: false >
    < FGinError: false, QaCTinError: B, QaAQinError: B1 >
    CONF}
    =>
    {< WH :Waterheater | Broken: yes, Status: whOff, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: true >
    < FGinError: true, QaCTinError: false, QaAQinError: false >
    deselect(CONF)}
    [print "rule: [AnalyseWaterheaterError]"] .

  rl [AnalyseWindowError] :
    {< H :Window | Broken: yes, Status: WS, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: false >
    < FGinError: false, QaCTinError: B, QaAQinError: B1 >
    CONF}
    =>
    {< H :Window | Broken: yes, Status: halfopen, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: true >
    < FGinError: true, QaCTinError: false, QaAQinError: false >
    deselect(CONF)}
    [print "rule: [AnalyseWindowError]"] .



  ******************************* PLAN and EXECUTE
  ************ Actuators in error
  *** If an actuator is broken and the FG is in error, then activate the actuator in error controller
  rl [PlanHeaterError] :
    < H :Heater | Broken: yes, Status: HS, A >
    < HEC :HeaterErrController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < FGinError: true, QaCTinError: false, QaAQinError: false >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    =>
    < H :Heater | Broken: yes, Status: hOff, A >
    < HEC :HeaterErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, HErr) >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < FGinError: false, QaCTinError: false, QaAQinError: false >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    [print "rule: [PlanHeaterError]"] .

  rl [PlanWaterheaterError] :
    < WH :Waterheater | Broken: yes, Status: WHS, A >
    < WHEC :WaterheaterErrController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < FGinError: true, QaCTinError: false, QaAQinError: false >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    =>
    < WH :Waterheater | Broken: yes, Status: whOff, A >
    < WHEC :WaterheaterErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, WhErr) >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < FGinError: false, QaCTinError: false, QaAQinError: false >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    [print "rule: [PlanWaterheaterError]"] .

  rl [PlanWindowError] :
    < W :Window | Broken: yes, Status: WS, A >
    < WEC :WindowErrController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < FGinError: true, QaCTinError: false, QaAQinError: false >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    =>
    < W :Window | Broken: yes, Status: halfopen, A >
    < WEC :WindowErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, WErr) >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < FGinError: false, QaCTinError: false, QaAQinError: false >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    [print "rule: [PlanWindowError]"] .






endm
eof
************* QA in error
crl [AnalyseQaInError] :
  {< MC :Metacontroller | MetaLog: ML >
  < RequiredQAs | requQaCT: RCT, requQaAQ: RAQ >
  < Scheduler | Status: MCAnalyse, RuleApplied: false >
  < FGinError: false, QaCTinError: B, QaAQinError: B1 >
  CONF}
  =>
  {< MC :Metacontroller | MetaLog: ML >
  < RequiredQAs | requQaCT: RCT, requQaAQ: RAQ >
  < Scheduler | Status: MCAnalyse, RuleApplied: true >
  < FGinError: true, QaCTinError: newB, QaAQinError: newB1 >
  CONF}
  if newB := (getQaCtMeas(CONF) < RCT) /\ newB1 := (getQaAqMeas < RAQ) /\ newB or newB1
  [print "rule: [AnalyseQaInError]"] .

************* QA not in error
crl [AnalyseQaGood] :
  {< MC :Metacontroller | MetaLog: ML >
  < RequiredQAs | requQaCT: RCT, requQaAQ: RAQ >
  < Scheduler | Status: MCAnalyse, RuleApplied: false >
  < FGinError: false, QaCTinError: B, QaAQinError: B1 >
  CONF}
  =>
  {< MC :Metacontroller | MetaLog: ML >
  < RequiredQAs | requQaCT: RCT, requQaAQ: RAQ >
  < Scheduler | Status: MCAnalyse, RuleApplied: true >
  < FGinError: false, QaCTinError: false, QaAQinError: false >
  CONF}
  if (getQaCtMeas(CONF) >= RCT) /\ (getQaAqMeas >= RAQ)
  [print "rule: [AnalyseQaGood]"] .




  ********** Cost function qualtiy attributes
  op cost : Configuration -> Rat .
  eq cost(CONF) = 5/10 * getQaComfValue(CONF) + 4/10 * getQaAqValue(CONF) + 1/10 * getQaEcoValue(CONF) .

  *** If no metacontroller is in initial configuration, we want to have a dummy rule s.t. we can test without metacontroller
  op noMetacontr : Configuration -> Bool .
  eq noMetacontr(< MC :Metacontroller | MetaLog: ML > CONF) = false .
  eq noMetacontr(CONF) = true [owise] .



*** TODO Should the metacontroller also turn the actuators off?
  ****************** Rules
  ****************************************** From comfort controller to error controller
  *** If the comfort or eco controller is active and the heater is broken, then activate the heater error controller
  rl [MetaContrHErr] :
    < H :Heater | Broken: yes, Status: HS, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < HEC :HeaterErrController | Selected: S2, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    =>
    < H :Heater | Broken: yes, Status: hOff, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S >
    < HEC :HeaterErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, HErr) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    [print "rule: [MetaContrHErr]"] .

  *** If the comfort or eco controller is active and the water heater is broken, then activate the water heater error controller
  rl [MetaContrWhErr] :
    < WH :Waterheater | Broken: yes, Status: WHS, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < WHEC :WaterheaterErrController | Selected: S2, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    =>
    < WH :Waterheater | Broken: yes, Status: whOff, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S >
    < WHEC :WaterheaterErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, WhErr) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    [print "rule: [MetaContrWhErr]"] .

  *** If the comfort or eco controller is active and the window is broken, then activate the window error controller
  rl [MetaContrWErr] :
    < W :Window | Broken: yes, Status: WS, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < WEC :WindowErrController | Selected: S2, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    =>
    < W :Window | Broken: yes, Status: halfopen, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S >
    < WEC :WindowErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, WErr) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    [print "rule: [MetaContrWErr]"] .


  ************************************** Change to comfort or eco controller
  *** If QA air purity >= 0.7 and QA comf < 7/10, then choose comfort controller
  crl [MetaContrChooseComf] :
    {< CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    CONF}
    =>
    {< CC :ComfortController | Selected: true >
    < EC :EcoController | Selected: S >
    < MC :Metacontroller | MetaLog: ML (TS, Comf) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    CONF}
    if oneBroken(CONF) == false /\ getQaAqValue(CONF) >= 5/10 /\ getQaComfValue(CONF) < 5/10
    [print "rule: [MetaContrChooseComf]"] .

  *** If QA comfort >= 0.7 and QA air purity < 0.7, then choose eco controller
  crl [MetaContrChooseEco] :
    {< EC :EcoController | Selected: S1, EQA >
    < CC :ComfortController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    CONF}
    =>
    {< EC :EcoController | Selected: true >
    < CC :ComfortController | Selected: S >
    < MC :Metacontroller | MetaLog: ML (TS, Eco) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    CONF}
    if oneBroken(CONF) == false /\ getQaComfValue(CONF) >= 5/10 /\ getQaAqValue(CONF) < 5/10
    [print "rule: [MetaContrChooseEco]"] .

  ************** If QA comfort >= 0.7 and QA air purity >= 0.7, then decide with cost function
  *** If cost < 0.7, then choose the comfort controller
  crl [MetaContrCostComf] :
    {< CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    CONF}
    =>
    {< CC :ComfortController | Selected: true >
    < EC :EcoController | Selected: S >
    < MC :Metacontroller | MetaLog: ML (TS, Eco) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    CONF}
    if oneBroken(CONF) == false /\ getQaComfValue(CONF) >= 5/10 /\ getQaAqValue(CONF) >= 5/10 /\ cost(CONF) < 7/10
    [print "rule: [MetaContrChooseCost]"] .

  *** If cost > 0.7, then choose the eco controller
  crl [MetaContrCostEco] :
    {< EC :EcoController | Selected: S1, EQA >
    < CC :ComfortController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    CONF}
    =>
    {< EC :EcoController | Selected: true >
    < CC :ComfortController | Selected: S >
    < MC :Metacontroller | MetaLog: ML (TS, Eco) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    CONF}
    if oneBroken(CONF) == false /\ getQaComfValue(CONF) >= 5/10 /\ getQaAqValue(CONF) >= 5/10 /\ cost(CONF) >= 7/10
    [print "rule: [MetaContrCostEco]"] .


  *************************** Dummy rules
  *** If there is no metacontroller, this rules ensures that we can run tests anyway
  crl [noMetacontroller] :
    {< Scheduler | Status: MCChange, RuleApplied: false > CONF}
    =>
    {< Scheduler | Status: MCChange, RuleApplied: true > CONF}
    if noMetacontr(CONF) == true
    [print "rule: [noMetacontr]"] .

endm
eof
