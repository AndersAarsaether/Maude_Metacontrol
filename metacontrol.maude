in comfort_controller.maude
in eco_controller.maude
in heater_err_controller.maude
in wh_error_controller.maude
in window_error_controller.maude
in qualityattributes.maude

mod METACONTROL is
  protecting COMFORTCONTROLLER .
  protecting ECOCONTROLLER .
  protecting HEATERERRCONTROLLER .
  protecting WATERHEATERERRCONTROLLER .
  protecting WINDOWERRCONTROLLER .
  protecting QUALITYATTRIBUTES .


  sort Metacontroller .
  subsort Metacontroller < Configuration .

  sorts ContrSelected MetaPair MetaLog .
  subsort MetaPair < MetaLog .
  ops Eco Comf HErr WhErr WErr Arb1 Arb2 : -> ContrSelected [ctor] .
  op (_, _) : Timesteps ContrSelected -> MetaPair [ctor] .
  op nil : -> MetaLog [ctor] .
  op __ : MetaLog MetaLog -> MetaLog [ctor assoc id: nil] .

  op < _ :Metacontroller | MetaLog: _ > : Oid MetaLog -> Metacontroller [format (ntr r r r r r r o)] .


  ********** Objects for Function Designs
  sorts ActuatorList FunctionDesign .
  subsort FunctionDesign < Configuration .

  ops heater waterheater window nil : -> ActuatorList [ctor] .
  op _, _ : ActuatorList ActuatorList -> ActuatorList [ctor assoc comm id: nil] .

  *** The FDs contain the Oid of the controller they are connected to
  op < _ :FDComfortController | ConController: _, ExpQaCT: _, ExpQaAP: _, RequActuators: _ > : Oid Oid Rat Rat ActuatorList -> FunctionDesign [format (ntr r r r r r r r r r r r r r r r o)] .
  op < _ :FDEcoController | ConController: _, ExpQaCT: _, ExpQaAP: _, RequActuators: _ > : Oid Oid Rat Rat ActuatorList -> FunctionDesign [format (ntr r r r r r r r r r r r r r r r o)] .
  op < _ :FDDegAController | ConController: _, ExpQaCT: _, ExpQaAP: _, RequActuators: _ > : Oid Oid Rat Rat ActuatorList -> FunctionDesign [format (ntr r r r r r r r r r r r r r r r o)] .
  op < _ :FDDegBController | ConController: _, ExpQaCT: _, ExpQaAP: _, RequActuators: _ > : Oid Oid Rat Rat ActuatorList -> FunctionDesign [format (ntr r r r r r r r r r r r r r r r o)] .
  op < _ :FDDegCController | ConController: _, ExpQaCT: _, ExpQaAP: _, RequActuators: _ > : Oid Oid Rat Rat ActuatorList -> FunctionDesign [format (ntr r r r r r r r r r r r r r r r o)] .

  ******** Object that indicates whether FG and QAs are in error.
  sort InError .
  subsort InError < Configuration .
  op < ErrorPropagation | FGinError: _, QaCTinError: _, QaAQinError: _, ActuatorsInError: _ > : Bool Bool Bool ActuatorList -> InError [format(ntc c c c c c c c c c c c c c c c)] .

  *** Get Oid of connected controller of a FD
  op getConContrOid : FunctionDesign -> Oid .
  eq getConContrOid(< FD :FDComfortController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >) = COid .
  eq getConContrOid(< FD :FDEcoController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >) = COid .
  eq getConContrOid(< FD :FDDegAController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >) = COid .
  eq getConContrOid(< FD :FDDegBController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >) = COid .
  eq getConContrOid(< FD :FDDegCController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >) = COid .

  *** Determine which FD has the highest QA CT value
  op highestQaCT : Configuration -> Rat .
  ceq highestQaCT(< FD :FDComfortController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = ECT if highestQaCT(CONF) < ECT .
  ceq highestQaCT(< FD :FDEcoController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = ECT if highestQaCT(CONF) < ECT .
  ceq highestQaCT(< FD :FDDegAController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = ECT if highestQaCT(CONF) < ECT .
  ceq highestQaCT(< FD :FDDegBController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = ECT if highestQaCT(CONF) < ECT .
  ceq highestQaCT(< FD :FDDegCController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = ECT if highestQaCT(CONF) < ECT .
  eq highestQaCT(CONF) = 0 [owise] .

  *** Determine which FD has the highest QA AP value
  op highestQaAP : Configuration -> Rat .
  ceq highestQaAP(< FD :FDComfortController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = EAP if highestQaAP(CONF) < EAP .
  ceq highestQaAP(< FD :FDEcoController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = EAP if highestQaAP(CONF) < EAP .
  ceq highestQaAP(< FD :FDDegAController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = EAP if highestQaAP(CONF) < EAP .
  ceq highestQaAP(< FD :FDDegBController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = EAP if highestQaAP(CONF) < EAP .
  ceq highestQaAP(< FD :FDDegCController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = EAP if highestQaAP(CONF) < EAP .
  eq highestQaAP(CONF) = 0 [owise] .

  *** Determine FD with highest QA CT value
  op FDhighestQaCT : Configuration -> FunctionDesign .
  ceq FDhighestQaCT(< FD :FDComfortController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDComfortController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaCT(CONF) < ECT .
  ceq FDhighestQaCT(< FD :FDEcoController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDEcoController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaCT(CONF) < ECT .
  ceq FDhighestQaCT(< FD :FDDegAController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDDegAController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaCT(CONF) < ECT .
  ceq FDhighestQaCT(< FD :FDDegBController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDDegBController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaCT(CONF) < ECT .
  ceq FDhighestQaCT(< FD :FDDegCController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDDegCController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaCT(CONF) < ECT .

  *** Determine FD with highest QA AP value
  op FDhighestQaAP : Configuration -> FunctionDesign .
  ceq FDhighestQaAP(< FD :FDComfortController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDComfortController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaAP(CONF) < EAP .
  ceq FDhighestQaAP(< FD :FDEcoController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDEcoController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaAP(CONF) < EAP .
  ceq FDhighestQaAP(< FD :FDDegAController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDDegAController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaAP(CONF) < EAP .
  ceq FDhighestQaAP(< FD :FDDegBController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDDegBController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaAP(CONF) < EAP .
  ceq FDhighestQaAP(< FD :FDDegCController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA > CONF)
    = < FD :FDDegCController | ConController: COid, ExpQaCT: ECT, ExpQaAP: EAP, RequActuators: RA >
    if highestQaAP(CONF) < EAP .

  *** Select controller whose Function Design has the highest QA CT value
  op selectFDhighestQaCT : Configuration -> Configuration .
  eq selectFDhighestQaCT(CONF) = selectContr(getConContrOid(FDhighestQaCT(CONF)), CONF) .

  *** Select controller whose Function Design has the highest QA AP value
  op selectFDhighestQaAP : Configuration -> Configuration .
  eq selectFDhighestQaAP(CONF) = selectContr(getConContrOid(FDhighestQaAP(CONF)), CONF) .

  *** Deselect Function Grounding
  op deselect : Configuration -> Configuration .
  eq deselect(< HEC :HeaterErrController | Selected: S > CONF) = < HEC :HeaterErrController | Selected: false > deselect(CONF) .
  eq deselect(< WHEC :WaterheaterErrController | Selected: S > CONF) = < WHEC :WaterheaterErrController | Selected: false > deselect(CONF) .
  eq deselect(< WEC :WindowErrController | Selected: S > CONF) = < WEC :WindowErrController | Selected: false > deselect(CONF) .
  eq deselect(< CC :ComfortController | Selected: S > CONF) = < CC :ComfortController | Selected: false > deselect(CONF) .
  eq deselect(< EC :EcoController | Selected: S > CONF) = < EC :EcoController | Selected: false  > deselect(CONF) .
  eq deselect(CONF) = CONF [owise] .

  vars H WH W CC EC HEC WHEC WEC MC QAC QAAQ C FD COid : Oid .
  var HS : HeaterStatus .
  var WHS : WaterheaterStatus .
  var WS : WindowStatus .
  var A : Attribute .
  var N N1 : Nat .
  var QAL QAL1 : List{Bool} .
  var QAS QAS1 : QaStatus .
  var QACOM QACOM1 : QAComputed .
  var CONF : Configuration .
  var SC : ScheduleComponents .
  vars B B1 B2 B3 newB newB1 : Bool .
  var R : Rat .
  var ML : MetaLog .
  var TS : Timesteps .
  var TI : Time .
  vars TL AL : TVPList .
  vars S S1 S2 : Selected .
  vars RCT RAQ ECT EAP : Rat .
  var RA AIE : ActuatorList .

  **************************** ANALYSE
  ************ Actuators in error
  *** If an actuator is broken, turn it off, set FG to be in error and QAs to be not in error
  *** (because we don't want to use the rules that include QAs)
  *** Put all controllers to 'not selected'
  *** We assume that only one actuator can be in error at a each time step
  rl [AnalyseHeaterError] :
    {< H :Heater | Broken: yes, Status: HS, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: false >
    < ErrorPropagation | FGinError: false, QaCTinError: B, QaAQinError: B1, ActuatorsInError: AIE >
    CONF}
    =>
    {< H :Heater | Broken: yes, Status: hOff, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: true >
    < ErrorPropagation | FGinError: true, QaCTinError: false, QaAQinError: false, ActuatorsInError: heater >
    deselect(CONF)}
    [print "rule: [AnalyseHeaterError]"] .

  rl [AnalyseWaterheaterError] :
    {< WH :Waterheater | Broken: yes, Status: WHS, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: false >
    < ErrorPropagation | FGinError: false, QaCTinError: B, QaAQinError: B1, ActuatorsInError: AIE >
    CONF}
    =>
    {< WH :Waterheater | Broken: yes, Status: whOff, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: true >
    < ErrorPropagation | FGinError: true, QaCTinError: false, QaAQinError: false, ActuatorsInError: waterheater >
    deselect(CONF)}
    [print "rule: [AnalyseWaterheaterError]"] .

  rl [AnalyseWindowError] :
    {< H :Window | Broken: yes, Status: WS, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: false >
    < ErrorPropagation | FGinError: false, QaCTinError: B, QaAQinError: B1, ActuatorsInError: AIE >
    CONF}
    =>
    {< H :Window | Broken: yes, Status: halfopen, A >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCAnalyse, RuleApplied: true >
    < ErrorPropagation | FGinError: true, QaCTinError: false, QaAQinError: false, ActuatorsInError: window >
    deselect(CONF)}
    [print "rule: [AnalyseWindowError]"] .

  ************* QA in error
  crl [AnalyseQaInError] :
    {< MC :Metacontroller | MetaLog: ML >
    < RequiredQAs | requQaCT: RCT, requQaAQ: RAQ >
    < QAC :QaComfort | Consider: N, Past: QAL, Status: QAS, QAComputed: QACOM >
    < QAAQ :QaAirquality | Consider: N1, Past: QAL1, Status: QAS1, QAComputed: QACOM1 >
    < Scheduler | Status: MCAnalyse, RuleApplied: false >
    < ErrorPropagation | FGinError: false, QaCTinError: B, QaAQinError: B1, ActuatorsInError: AIE >
    CONF}
    =>
    {< MC :Metacontroller | MetaLog: ML >
    < RequiredQAs | requQaCT: RCT, requQaAQ: RAQ >
    < QAC :QaComfort | Consider: N, Past: QAL, Status: QAS, QAComputed: QACOM >
    < QAAQ :QaAirquality | Consider: N1, Past: QAL1, Status: QAS1, QAComputed: QACOM1 >
    < Scheduler | Status: MCAnalyse, RuleApplied: true >
    < ErrorPropagation | FGinError: true, QaCTinError: newB, QaAQinError: newB1, ActuatorsInError: AIE >
    deselect(CONF)}
    if newB := (QAS < RCT) /\ newB1 := (QAS1 < RAQ) /\ newB or newB1
    [print "rule: [AnalyseQaInError]"] .

  ************* QA not in error
  crl [AnalyseQaGood] :
    {< MC :Metacontroller | MetaLog: ML >
    < RequiredQAs | requQaCT: RCT, requQaAQ: RAQ >
    < QAC :QaComfort | Consider: N, Past: QAL, Status: QAS, QAComputed: QACOM >
    < QAAQ :QaAirquality | Consider: N1, Past: QAL1, Status: QAS1, QAComputed: QACOM1 >
    < Scheduler | Status: MCAnalyse, RuleApplied: false >
    < ErrorPropagation | FGinError: false, QaCTinError: B, QaAQinError: B1, ActuatorsInError: AIE >
    CONF}
    =>
    {< MC :Metacontroller | MetaLog: ML >
    < RequiredQAs | requQaCT: RCT, requQaAQ: RAQ >
    < QAC :QaComfort | Consider: N, Past: QAL, Status: QAS, QAComputed: QACOM >
    < QAAQ :QaAirquality | Consider: N1, Past: QAL1, Status: QAS1, QAComputed: QACOM1 >
    < Scheduler | Status: MCAnalyse, RuleApplied: true >
    < ErrorPropagation | FGinError: false, QaCTinError: false, QaAQinError: false , ActuatorsInError: AIE >
    CONF}
    if (QAS >= RCT) /\ (QAS1 >= RAQ)
    [print "rule: [AnalyseQaGood]"] .




  ******************************* PLAN and EXECUTE
  ************ Actuators in error
  *** If an actuator is broken and the FG is in error, then activate the actuator in error controller
  rl [PlanHeaterError] :
    < H :Heater | Broken: yes, Status: HS, A >
    < HEC :HeaterErrController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < ErrorPropagation | FGinError: true, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    =>
    < H :Heater | Broken: yes, Status: hOff, A >
    < HEC :HeaterErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, HErr) >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < ErrorPropagation | FGinError: false, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    [print "rule: [PlanHeaterError]"] .

  rl [PlanWaterheaterError] :
    < WH :Waterheater | Broken: yes, Status: WHS, A >
    < WHEC :WaterheaterErrController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < ErrorPropagation | FGinError: true, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    =>
    < WH :Waterheater | Broken: yes, Status: whOff, A >
    < WHEC :WaterheaterErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, WhErr) >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < ErrorPropagation | FGinError: false, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    [print "rule: [PlanWaterheaterError]"] .

  rl [PlanWindowError] :
    < W :Window | Broken: yes, Status: WS, A >
    < WEC :WindowErrController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < ErrorPropagation | FGinError: true, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    =>
    < W :Window | Broken: yes, Status: halfopen, A >
    < WEC :WindowErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, WErr) >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < ErrorPropagation | FGinError: false, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    [print "rule: [PlanWindowError]"] .


  *** TODO Maybe make a function that returns all available FDs

  *** TODO Metacontrol log
  *** QA CT in error and maybe QA AP in error (prefer QA CT)
  rl [PlanQaCtInError] :
    {< MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < ErrorPropagation | FGinError: true, QaCTinError: true, QaAQinError: B, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    CONF}
    =>
    {< MC :Metacontroller | MetaLog: ML (TS, Arb1) >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < ErrorPropagation | FGinError: false, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    selectFDhighestQaCT(CONF)}
    [print "rule: [PlanQaCtInError]"] .

  *** QA AP and not QA CT in error
  rl [PlanQaApInError] :
    {< MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < ErrorPropagation | FGinError: true, QaCTinError: false, QaAQinError: true, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    CONF}
    =>
    {< MC :Metacontroller | MetaLog: ML (TS, Arb2) >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < ErrorPropagation | FGinError: false, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    selectFDhighestQaAP(CONF)}
    [print "rule: [PlanQaApInError]"] .

  *** Nothing new is planned if FG is not in error
  rl [PlanQaGood] :
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: false >
    < ErrorPropagation | FGinError: false, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    =>
    < MC :Metacontroller | MetaLog: ML >
    < Scheduler | Status: MCPlan, RuleApplied: true >
    < ErrorPropagation | FGinError: false, QaCTinError: false, QaAQinError: false, ActuatorsInError: AIE >
    [print "rule: [PlanQaGood]"] .
endm
eof



  ********** Cost function qualtiy attributes
  op cost : Configuration -> Rat .
  eq cost(CONF) = 5/10 * getQaComfValue(CONF) + 4/10 * getQaAqValue(CONF) + 1/10 * getQaEcoValue(CONF) .

  *** If no metacontroller is in initial configuration, we want to have a dummy rule s.t. we can test without metacontroller
  op noMetacontr : Configuration -> Bool .
  eq noMetacontr(< MC :Metacontroller | MetaLog: ML > CONF) = false .
  eq noMetacontr(CONF) = true [owise] .



*** TODO Should the metacontroller also turn the actuators off?
  ****************** Rules
  ****************************************** From comfort controller to error controller
  *** If the comfort or eco controller is active and the heater is broken, then activate the heater error controller
  rl [MetaContrHErr] :
    < H :Heater | Broken: yes, Status: HS, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < HEC :HeaterErrController | Selected: S2, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    =>
    < H :Heater | Broken: yes, Status: hOff, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S >
    < HEC :HeaterErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, HErr) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    [print "rule: [MetaContrHErr]"] .

  *** If the comfort or eco controller is active and the water heater is broken, then activate the water heater error controller
  rl [MetaContrWhErr] :
    < WH :Waterheater | Broken: yes, Status: WHS, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < WHEC :WaterheaterErrController | Selected: S2, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    =>
    < WH :Waterheater | Broken: yes, Status: whOff, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S >
    < WHEC :WaterheaterErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, WhErr) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    [print "rule: [MetaContrWhErr]"] .

  *** If the comfort or eco controller is active and the window is broken, then activate the window error controller
  rl [MetaContrWErr] :
    < W :Window | Broken: yes, Status: WS, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < WEC :WindowErrController | Selected: S2, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    =>
    < W :Window | Broken: yes, Status: halfopen, A >
    < CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S >
    < WEC :WindowErrController | Selected: true >
    < MC :Metacontroller | MetaLog: ML (TS, WErr) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    [print "rule: [MetaContrWErr]"] .


  ************************************** Change to comfort or eco controller
  *** If QA air purity >= 0.7 and QA comf < 7/10, then choose comfort controller
  crl [MetaContrChooseComf] :
    {< CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    CONF}
    =>
    {< CC :ComfortController | Selected: true >
    < EC :EcoController | Selected: S >
    < MC :Metacontroller | MetaLog: ML (TS, Comf) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    CONF}
    if oneBroken(CONF) == false /\ getQaAqValue(CONF) >= 5/10 /\ getQaComfValue(CONF) < 5/10
    [print "rule: [MetaContrChooseComf]"] .

  *** If QA comfort >= 0.7 and QA air purity < 0.7, then choose eco controller
  crl [MetaContrChooseEco] :
    {< EC :EcoController | Selected: S1, EQA >
    < CC :ComfortController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    CONF}
    =>
    {< EC :EcoController | Selected: true >
    < CC :ComfortController | Selected: S >
    < MC :Metacontroller | MetaLog: ML (TS, Eco) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    CONF}
    if oneBroken(CONF) == false /\ getQaComfValue(CONF) >= 5/10 /\ getQaAqValue(CONF) < 5/10
    [print "rule: [MetaContrChooseEco]"] .

  ************** If QA comfort >= 0.7 and QA air purity >= 0.7, then decide with cost function
  *** If cost < 0.7, then choose the comfort controller
  crl [MetaContrCostComf] :
    {< CC :ComfortController | Selected: S >
    < EC :EcoController | Selected: S1, EQA >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    CONF}
    =>
    {< CC :ComfortController | Selected: true >
    < EC :EcoController | Selected: S >
    < MC :Metacontroller | MetaLog: ML (TS, Eco) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    CONF}
    if oneBroken(CONF) == false /\ getQaComfValue(CONF) >= 5/10 /\ getQaAqValue(CONF) >= 5/10 /\ cost(CONF) < 7/10
    [print "rule: [MetaContrChooseCost]"] .

  *** If cost > 0.7, then choose the eco controller
  crl [MetaContrCostEco] :
    {< EC :EcoController | Selected: S1, EQA >
    < CC :ComfortController | Selected: S >
    < MC :Metacontroller | MetaLog: ML >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: false >
    CONF}
    =>
    {< EC :EcoController | Selected: true >
    < CC :ComfortController | Selected: S >
    < MC :Metacontroller | MetaLog: ML (TS, Eco) >
    < C :Clock | Timesteps: TS, Time: TI, TempLog: TL, AqLog: AL >
    < Scheduler | Status: MCChange, RuleApplied: true >
    CONF}
    if oneBroken(CONF) == false /\ getQaComfValue(CONF) >= 5/10 /\ getQaAqValue(CONF) >= 5/10 /\ cost(CONF) >= 7/10
    [print "rule: [MetaContrCostEco]"] .


  *************************** Dummy rules
  *** If there is no metacontroller, this rules ensures that we can run tests anyway
  crl [noMetacontroller] :
    {< Scheduler | Status: MCChange, RuleApplied: false > CONF}
    =>
    {< Scheduler | Status: MCChange, RuleApplied: true > CONF}
    if noMetacontr(CONF) == true
    [print "rule: [noMetacontr]"] .

endm
eof
